package net.gaast.giggity;

import android.content.Context;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.os.Handler;
import android.os.Looper;
import android.preference.PreferenceManager;

import org.apache.commons.io.IOUtils;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;

import androidx.test.ext.junit.runners.AndroidJUnit4;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

@RunWith(AndroidJUnit4.class)
public class DbTest {
	Giggity app;
	Context me;

	@Before
	public void setUp() {
		app = (Giggity) getInstrumentation().getTargetContext().getApplicationContext();
		me = getInstrumentation().getContext();

		SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(app);
		SharedPreferences.Editor p = pref.edit();
		// This tracks the most recently loaded seed version number, which shouldn't carry across
		// test runs. (Though also I think this seed version concept should just go away..)
		p.remove("last_menu_seed_version");
		p.commit();
	}

	private void loadDb(int id) throws IOException {
		// Regenerating files:
		// rm -f *.sqlite; for f in *.sql; do sqlite3 ${f/./bin.}ite < $f; done
		try (OutputStream out = new FileOutputStream(app.getDatabasePath("dut").getPath())) {
			IOUtils.copy(me.getResources().openRawResource(id), out);
		}
	}

	@Test
	public void testUpgradeEmptyDb18() throws IOException {
		loadDb(net.gaast.giggity.test.R.raw.db18bin);

		Db db = new Db(app, "dut", null);
		Db.Connection c = db.getConnection();
		// Nothing is actually opened until this call:
		Assert.assertNotEquals(0, c.getScheduleList().size());
	}

	@Test
	public void testUpgradePopulatedApk531() throws IOException {
		loadDb(net.gaast.giggity.test.R.raw.apk531bin);

		String seed = IOUtils.toString(me.getResources().openRawResource(net.gaast.giggity.test.R.raw.menu531), StandardCharsets.UTF_8);

		Db db = new Db(app, "dut", seed);
		Db.Connection c = db.getConnection();
		for (Db.DbSchedule s : c.getScheduleList()) {
			// (I'm lucky that no quoting/escaping is breaking this one.)
			assert(seed.contains(s.getTitle()));
			assert(seed.contains(s.getUrl()));
			Assert.assertNotNull(s.getTimezone());
			// The incoming database file was generated by a very old Giggity which wasn't setting
			// sch_id_s yet, but that should've gotten backfilled by this point.
			assert(s.hasId());
		}
	}

	@Test
	public void testDataUpdatesOnly() throws IOException {
		// Well OK it's data only right now but some day I'll update the schema gain I guess. :)
		loadDb(net.gaast.giggity.test.R.raw.dataonlybin);

		String seed = IOUtils.toString(me.getResources().openRawResource(net.gaast.giggity.test.R.raw.menu2026), StandardCharsets.UTF_8);

		final String goodUrl = "https://program.why2025.org/why2025/schedule/export/schedule.xml";
		final String badUrl = "https://cfp.why2025.org/why2025/schedule/export/schedule.xml";

		Db db = new Db(app, "dut", seed);
		Db.Connection c = db.getConnection();
		for (Db.DbSchedule s : c.getScheduleList()) {
			// Check that corrected data isn't there yet.
			Assert.assertNotEquals("39C3 - merged", s.getTitle());
			Assert.assertNotEquals(goodUrl, s.getUrl());
		}
		// Until now the seed didn't get touched, above checks for my corruptions in the db dump,
		// which we're now going to clean up.
		c.refreshScheduleList();
		for (Db.DbSchedule s : c.getScheduleList()) {
			// Corrupted title from database should've been corrected using seed data.
			Assert.assertNotEquals("39C3 (merged)", s.getTitle());
			if (s.getTitle().equals("39C3 - merged")) {
				Assert.assertFalse(s.getHidden());
			}
			if (s.getTitle().equals("39C3 - main rooms only")) {
				Assert.assertTrue(s.getHidden());
			}
			// Old URL also should've been updated and not be anywhere in the database anymore.
			Assert.assertNotEquals(badUrl, s.getUrl());
			if (s.getTitle().equals("WHY2025")) {
				Assert.assertEquals(goodUrl, s.getUrl());
			}
		}
	}

	@Test
	public void testDedupe() throws IOException {
		loadDb(net.gaast.giggity.test.R.raw.fosdemdedupebin);

		String seed = IOUtils.toString(me.getResources().openRawResource(net.gaast.giggity.test.R.raw.menu2026), StandardCharsets.UTF_8);

		final String badUrl = "https://fosdem.org/this/is/a/weird/url";
		final String goodUrl = "https://fosdem.org/2026/schedule/xml";

		Db db = new Db(app, "dut", seed);
		Db.Connection c = db.getConnection();
		Assert.assertEquals(2, c.getScheduleList().size());

		c.refreshScheduleList();
		for (Db.DbSchedule s : c.getScheduleList()) {
			// Corrupted title from database should've been corrected using seed data.
			Assert.assertNotEquals(s.getUrl(), badUrl);
		}

		// Note: This causes confusing "Creating new database" stuff getting logged because of
		// app.getDb() getting called deep inside. It's confusing but doesn't break this test.
		// Also, this is loading real schedule data from fosdem.org. Some day I should bother
		// to mock that but so far FOSDEM scheduled have remained online for *years* reliably.
		Schedule sched = ScheduleUI.loadSchedule(app, goodUrl, Fetcher.Source.CACHE, new Handler(Looper.getMainLooper()));
		c.setSchedule(sched, goodUrl, true);
		sched.addMetadata(c.getMetadata());

		int r = 0;
		for (Schedule.Line tent : sched.getTents()) {
			for (Schedule.Item item : tent.getItems()) {
				if (item.getRemind()) {
					++r;
				}
			}
		}
		Assert.assertEquals(7, r);
		Assert.assertNotNull(sched.getIconUrl());
		Assert.assertNotEquals(0, sched.getLinks().size());

		// Check that the duplicate entries (hello undefined behaviour!) are really gone.
		try (SQLiteDatabase rawdb = SQLiteDatabase.openDatabase(app.getDatabasePath("dut").getPath(), null, SQLiteDatabase.OPEN_READONLY)) {
			try (Cursor q = rawdb.rawQuery("Select Count(*) From schedule_item", null)) {
				q.moveToFirst();
				Assert.assertEquals(7, q.getInt(0));
			}
			try (Cursor q = rawdb.rawQuery("Select Count(*) From schedule Where sch_id_s = \"fosdem_2026\" And sch_title = \"FOSDEM 2026\"", null)) {
				q.moveToFirst();
				Assert.assertEquals(1, q.getInt(0));
			}
		}
	}
}
